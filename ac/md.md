# KMP与tire树

## KMP
##### 作用
快速的在A串中找出B串。
##### 与朴素字符串匹配的区别
假设在A串中找出B串，朴素算法中首先将A串的首字符与B串的首字符对齐，查验指针在A[0]，从A[0]开始向右验证每一位是否一致，如果不一致则将B串右移一位，将A[1]与B[0]对齐，查验的指针回溯至A[1]开始，向右验证每一位是否一致。以此类推。
##### 优化
取消了查验指针的回溯。得以在O(n)内完成匹配。
##### 优化原理
利用“公共前后缀”，将有时过多的回溯剪枝。假设B串在x处（A[y]）失配，将B[0]移到A[x+1]处，则有可能因为B[0]与A[x]一致而导致右移过多。以此可知将B[0]从A[x]尽量向左移动，如果出现一致的子串则可以在这里尝试匹配。“尽量向左移动”则为公共前后缀
##### 构建公共前后缀的方法
[视频](https://vdn.vzuu.com/SD/0b41f1c6-b361-11e9-8564-0a580a432806.mp4?disable_local_cache=1&bu=http-com&expiration=1586117907&auth_key=1586117907-0-0-7d2131f3411da42d81510833a1f5838e&f=mp4&v=ali)<br>
假设在0...l时有x位的公共前后缀aad......aa，则长度为l+1时只需要看s[l+1]是否为d，如果为d则公共最长前后缀为x+1，否则需要重新朴素匹配。(是否存在优化方法，存疑)<br>
s[0]的公共前后缀为0

##### 匹配的方法
在构建最长公共前后缀maxL[]后，将maxL向右移动一位，而首位赋值为-1.构建next数组<br>
<font color=#7B68EE size=2 face="黑体">ps.其实可以整合在一起进行</font><br>
<font color=#7B68EE size=2 face="黑体">next数组在失配后自动将B串指针i的next[i]的索引移动到A串指针j上。注：i与j是对齐改为next[i]与j对齐，也就是从i<->j ===> next[i]<->j</font><br>

## tire树
### 前言
0403的多校赛的B题可以作为tire树的模板。
### 应用
以题目为例 <br>
[UCF “Practice” Local Contest — Aug 25, 2018
Call Me Maybe](http://210.44.144.221/public/problems/19/text)<br>
我做东方鬼畜音mad,现有银语百连发一本。我草拟了音mad台词，需要编程告诉我音mad台词分别从淫语百连发中的哪一行那一节去找？(example:银梦四章 13:25)。为了音mad多样性，台词中同样的台词的来源应当是百连发所有同样的词的词源集合的循环。比如soudayo出自11：45和14：19,那么台词中出现了三回啊三回soudayo，则词源应该为11:45,14:19,11:45。
#### 解决方法
用所有出现的词建一个树，第一个字母在第一层，第二个字母在第二层，（根节点第0层），出现的层数即为z字母所在位数。<br>
那么，有26^最长单词位数个节点。通过剪枝，建立一个tot，在建树过程中，如果出现了一个新的节点，就把tree[now].next[ch]（now是当前节点,ch下面一个字母)赋值为++tot。根据c++的编译原理，next中其他的字母如果没有赋值，是不会被占用的，故空间被化简为节点总个数。<br>
那么node里则有next[]了<br>
建树时，在单词的某尾那个节点中添加一个cnt以表明这个单词到了结尾了。<br>
那么node里则有next[]和cnt了。<br>
此题的循环机制较为特殊，故cnt不是有无“01”,而是百连发中出现的次数。建立一个vector和now存储所有出现的地址与已经用了多少次。<br>
那么node里则有next[],cnt,now,vec。<br>
查找时每次+1%vec.size()
<br>这就是tire树以及应用
#### 2020年4月6日